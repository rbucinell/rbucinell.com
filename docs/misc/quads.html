<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Ryan Bucinell - Javascript Quads</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Ryan Bucinell">
    <link rel="icon" type="image/png" href="/img/icons/rb3.ico">
    <link rel="stylesheet" type="text/css" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/baguettebox.js/1.11.1/baguetteBox.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/devicons/devicon@master/devicon.min.css">
    <link rel="stylesheet" type="text/css" href="/css/lib.min.css">
    <link rel="stylesheet" type="text/css" href="/css/style.min.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto+Condensed" type="text/css">
    <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/baguettebox.js/1.11.1/baguetteBox.min.js"></script>
    <script>
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-16330943-1']);
      _gaq.push(['_trackPageview']);
      
      (function() {
          var ga = document.createElement( 'script');
          ga.type = 'text/javascript';
          ga.async = true;
          ga.src = ( 'https:' == document.location.protocol ? 'https://ssl' : 'http://www' ) + '.google-analytics.com/ga.js';
          var s = document.getElementsByTagName('script')[0];
          s.parentNode.insertBefore(ga,s);
      })();
    </script>
  </head>
  <body>
      <nav class="navbar navbar-inverse navbar-fixed-top navbar-expand-sm navbar-light">
        <div class="nav-brand"><a class="navbar-brand" href="/index.html"><span><img class="img-circle" alt="Ryan Bucinell's Headshot" src="/img/me/rmb.png"></span><span class="text-dark font-weight-bold">Ryan Bucinell&nbsp;</span><span class="text-white text-xs block d-none d-xs-block" id="mytitle">Software Engineer</span></a></div>
        <div class="button navbar-toggler" type="button" data-toggle="collapse" data-target="#mainNavigation"><span class="navbar-toggler-icon"></span></div>
        <div class="collapse navbar-collapse" id="mainNavigation">
          <ul class="navbar-nav mr-auto">
            <li class="nav-item"><a class="nav-link" href="/index.html">Home</a></li>
            <li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href="#" data-toggle="dropdown">Projects</a>
              <div class="dropdown-menu"><a class="dropdown-item" href="/projects.html">Active Projects</a><a class="dropdown-item" href="/code.html">Code</a><a class="dropdown-item" href="/flash.html">Flash</a><a class="dropdown-item" href="/websites.html">Websites</a><a class="dropdown-item" href="/graphics.html">Graphics</a></div>
            </li>
            <li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href="#" data-toggle="dropdown">Personal Info</a>
              <div class="dropdown-menu"><a class="dropdown-item" href="/about.html">About Me</a><a class="dropdown-item" href="/resume.html">Résumé</a></div>
            </li>
            <li class="nav-item"><a class="nav-link" href="/retro.html">History</a></li>
          </ul>
        </div>
      </nav>
      <div class="container">
        <div id="page-wrapper">
          <div class="container-fluid">
            <!--Page Header-->
            <div class="row">
              <div class="col-lg-12">
                <h1 class="page-header">Javascript Quads&nbsp;<small class="text-muted">Digitize!</small></h1>
                <ol class="breadcrumb">
                  <li><i data-feather="home"></i><span><a href="index.html">Home</a></span><span>&nbsp;/&nbsp;</span></li>
                  <li><i data-feather="settings"></i><span>Projects</span><span>&nbsp;/&nbsp;</span></li>
                  <li class="font-weight-bold"><i data-feather="code"></i><span>JS Quads</span></li>
                </ol>
              </div>
            </div>
            <div class="container-fluid">
              <div class="row" id="buttons">
                <button class="m-1 btn btn-primary" id="playButton" onclick="play()">Play</button>
                <div class="mx-1">
                  <div class="custom-file">
                    <input class="custom-file-input" type="file" accept="image/*" onchange="loadAll()">
                    <label class="custom-file-label">Choose File</label>
                  </div>
                </div>
                <button class="m-1 btn btn-secondary" id="pauseButton" onclick="step()">Step</button>
                <button class="m-1 btn btn-secondary" id="stopButton" onclick="stop()">Stop</button>
                <button class="m-1 btn btn-secondary" id="createButton" onclick="create()">Convert to Picture</button>
                <p class="lead" id="saveMe" style="display:none;">Right click to save me! </p>
              </div>
              <div class="row custom-control custom-radio" id="cellStyleButtons">
                <div class="custom-control custom-radio custom-control-inline">
                  <input class="custom-control-input" id="defaultInline1" type="radio" name="shadingRadios" checked="checked">
                  <label class="custom-control-label" for="defaultInline1">Box Shade</label>
                </div>
                <div class="custom-control custom-radio custom-control-inline">
                  <input class="custom-control-input" id="defaultInline2" type="radio" name="shadingRadios">
                  <label class="custom-control-label" for="defaultInline2">Box Bodrder</label>
                </div>
                <div class="custom-control custom-radio custom-control-inline">
                  <input class="custom-control-input" id="defaultInline3" type="radio" name="shadingRadios">
                  <label class="custom-control-label" for="defaultInline3">Hatch</label>
                </div>
                <div class="custom-control custom-radio custom-control-inline">
                  <input class="custom-control-input" id="defaultInline4" type="radio" name="shadingRadios">
                  <label class="custom-control-label" for="defaultInline4">HatchShaded</label>
                </div>
              </div>
              <div class="row"><img class="col" id="refpix" style="border:1px solid #000000;margin: 5px;" src="">
                <canvas class="col" id="canvas" style="border:1px solid #000000;margin: 5px;">
                  <p>Your browser doesn&apos;t support canvas.</p>
                </canvas>
              </div>
              <script>
                 //GLOBAL VARIABLES
var AREA_POWER = 0.25;
var MAX_DIVISIONS = 10;
var MAX_LINE_WIDTH = 4;

const DrawMode = {
	BOX:		"Box",
	BOXBORDER: 	"BoxBorder",
	HATCH:		"Hatch",
	HATCHSHADE:	"HatchShaded"
};

/**
*	Box constructor
**/
function Box( image, parent, x, y, w, h, depth, MAX_DEPTH )
{
	this.parent = parent;
	this.image = image;
	this.x = x;
	this.y = y;
	this.w = w;
	this.h = h;
	this.depth = depth;
	this.MAX_DEPTH = MAX_DEPTH;
	this.hatchWidth =  Math.tan( Math.atan( MAX_LINE_WIDTH / MAX_DEPTH ) )* ( MAX_DEPTH - this.depth);
	this.children = [];
	this.hist = new Histogram( this.image, x, y, w, h );
	this.setColor( this.hist.averageColor() );
	this.score = -this.error * Math.pow( this.area(), AREA_POWER );
	this.mode = DrawMode.BOX;
}

/**
* Determines if there are no children to this node
**/
Box.prototype.isLeaf = function()
{
	if( this.children.length === 0 )
	{
		return true;
	}
	return false;
};

/**
* Gets the children nodes to this box
**/
Box.prototype.getLeafNodes = function()
{
	if( this.children === [] )
	{
		return [ this ];
	}
	else
	{
		return this.children;
	}
};

Box.prototype.getAllLeafNodes = function( currentlist, maxdepth )
{
	if( this.depth >= maxdepth )
	{

	}
	else if( this.isLeaf() )
	{
		currentlist.push( this );
	}
	else
	{
		for( var i = 0; i < this.children.length; i++ )
		{
			currentlist = this.children[i].getAllLeafNodes( currentlist, maxdepth );
		}
	}
	return currentlist;
};

/**
* Gets the children nodes to this box up to a maximum depth given
**/
Box.prototype.getLeafNodes = function( depth )
{
	if( this.depth >= depth )
	{
		return [ this ];
	}
	else if( this.children === [])
	{
		return [ this ];
	}
	else
	{
		return this.children;
	}
};

/**
* Generate children nodes for this box
**/
Box.prototype.divide = function()
{

	var w2 = this.w / 2;
	var h2 = this.h / 2;

	var q1 = new Box(this.image, this, this.x, 	    this.y, 	 w2, h2, this.depth+1, this.MAX_DEPTH );
	var q2 = new Box(this.image, this, this.x + w2, this.y, 	 w2, h2, this.depth+1, this.MAX_DEPTH );
	var q3 = new Box(this.image, this, this.x, 	    this.y + h2, w2, h2, this.depth+1, this.MAX_DEPTH );
	var q4 = new Box(this.image, this, this.x + w2, this.y + h2, w2, h2, this.depth+1, this.MAX_DEPTH );

	this.children =[ q1, q2, q3, q4 ];
};

/**
* Draw the box's current color and if enabled, a border
**/
Box.prototype.draw = function( ctx )
{
	ctx.fillStyle = this.color;

	switch( this.mode )
	{
		case DrawMode.BOXBORDER:
			ctx.beginPath();
			ctx.lineWidth="0.1";
			ctx.strokeStyle= "black";//this.color;
			ctx.rect( this.x, this.y, this.w, this.h );
			ctx.stroke();
		/* falls through */
		case DrawMode.BOX:
			ctx.fillRect( this.x, this.y, this.w, this.h );
			break;
		case DrawMode.HATCHSHADE:
			ctx.globalAlpha = 0.2;
			ctx.fillRect( this.x, this.y, this.w, this.h );
			ctx.globalAlpha = 1;
		/* falls through */
		case DrawMode.HATCH:
			//determine the number of hatches in a square
			var divisions = MAX_DIVISIONS / (this.depth + 1);
			var vHatches = this.w / divisions;
			var hHatches = this.h / divisions;

			//The deeper we go, the finer our hatches become
			ctx.lineWidth = this.hatchWidth;
			ctx.strokeStyle = this.color;

			ctx.beginPath();


			var i = 0;
			for( i = 0; i < divisions; i++ )
			{
				//Verticle hatches
				ctx.moveTo(this.x+ i*vHatches, this.y);
				ctx.lineTo(this.x+ i*vHatches, this.y+ this.h);

				//Horizontal hatches
				ctx.moveTo(this.x, this.y+ i*hHatches);
				ctx.lineTo(this.x + this.w, this.y+ i*hHatches);

			}
			ctx.stroke();

			for( i = 0; i < divisions; i++ )
			{
				ctx.beginPath();
				ctx.stroke();
			}
			break;
	}

};

/**
* Sets the color and error of the box for the given Color c
**/
Box.prototype.setColor = function( c )
{
	this.color = "rgb("+Math.floor(c.r)+","+Math.floor(c.g)+","+Math.floor(c.b)+")";
	this.error = c.e;
};

/**
* returns the area of the box
**/
Box.prototype.area = function()
{
	return this.w * this.h;
};
                
class Histogram
{
	constructor( image, x, y, w, h)
	{
		this.image = image;
		this.x = x;
		this.y = y;
		this.w = w;
		this.h = h;

		this.r_offset = 0;
		this.g_offset = 1;
		this.b_offset = 2;
		this.a_offset = 3;

		this.bufferCanvas = document.createElement('canvas');
		this.buffer = this.bufferCanvas.getContext('2d');

		this.imageDAta;

		//Histogram Channels
		this.r = [];
		this.g = [];
		this.b = [];

		this.buildHist();
	}

	/**
	* Builds the Histogram from the given image data
	**/
	buildHist()
	{
		//first initialize r, g, and b
		this.r = this.newFilledArray( Histogram.COLOR_RANGE, 0 );
		this.g = this.newFilledArray( Histogram.COLOR_RANGE, 0 );
		this.b = this.newFilledArray( Histogram.COLOR_RANGE, 0 );

		////Fill buffer, and get image data from it
		this.buffer.drawImage( this.image, this.x, this.y, this.w, this.h, this.x, this.y, this.w, this.h);
		this.imgData = this.buffer.getImageData( this.x, this.y, this.w, this.h );

		//fill them with data
		for( let i = 0, l = this.imgData.data.length; i < l; i+=4 )
		{
			//add a red color
			let rVal = this.imgData.data[ i + this.r_offset ];
			this.r[rVal] = this.r[rVal] + 1;

			//add a green color
			let gVal = this.imgData.data[ i + this.g_offset ];
			this.g[gVal] = this.g[gVal] + 1;

			//add a blue color
			let bVal = this.imgData.data[ i + this.b_offset ];
			this.b[bVal] = this.b[bVal] + 1;
		}
	}

	newFilledArray(length, val)
	{
		let array = [];
		let i = 0;

		while (i < length)
		{
			array[i++] = val;
		}
		return array;
	}

	/**
	* Returns the weighted average of a set of data of a color channel histogram
	*/
	weightedAverage( data )
	{
		let total = 0, 
			value = 0, 
			error = 0, 
			i = 0,
			l = data.length;

		for( i = 0, l = data.length; i < l; i++ )
		{
			total += data[i];
			value += data[i] * i;
		}
		value = value / total;

		for( i = 0, l = data.length; i < l; i++ )
		{
			error += ( data[i] * Math.pow(( value - i ),2));
		}
		error = Math.sqrt( error / total );

		return { value: value, error: error };
	}

	/**
	* The weighted average of colors
	**/
	averageColor()
	{
		let rColor = this.weightedAverage( this.r );
		let gColor = this.weightedAverage( this.g );
		let bColor = this.weightedAverage( this.b );

		//standard NTSC conversion formula
		let error = rColor.error * Histogram.RED_ERROR_WEIGHT +
					gColor.error * Histogram.GREEN_ERROR_WEIGHT +
					bColor.error * Histogram.BLUE_ERROR_WEIGHT;
					
		return {
			r: rColor.value,
			g: gColor.value,
			b: bColor.value,
			e: error
		};
	}
}

Histogram.COLOR_RANGE = 256;
Histogram.RED_ERROR_WEIGHT   = 0.2989;
Histogram.GREEN_ERROR_WEIGHT = 0.5870;
Histogram.BLUE_ERROR_WEIGHT  = 0.1140;//GLOBAL VARIABLES


//Class public vars
const ERROR_RATE = 0.5;
const DEBUG_MODE = false;

class Quadrants
{
	constructor( canvas )
	{
		this.canvas = canvas;
		this.ctx = this.canvas.getContext('2d');
		this.bufferCanvas = document.createElement('canvas');
		this.buffer = this.bufferCanvas.getContext('2d');

		// Member variables
		this.intervalID	= -1;
		this.framerate 	= 20; //60
		this.isRunning 	= false;
		this.boxes = [];
		this.root;
		this.drawNode;
		this.hist;
		this.previousError = -1;
		this.error = 0;
		this.errorSum;

		this.ITERATIONS = 1024;
		this.MAX_DEPTH = 8;
	}

	initialize( img )
	{
		//Draw original image to get image data
		this.ctx.drawImage( img, 0, 0, img.naturalWidth, img.natualHeight, 0, 0, this.canvas.width, this.canvas.height);
		//g_imageData = this.ctx.getImageData(0,0, this.canvas.width, this.canvas.height);
		this.ctx.clearRect( 0, 0, this.canvas.width, this.canvas.height);

		//Create the starting root node
		this.root = new Box( img, {},  0, 0, this.canvas.width, this.canvas.height, 0, this.MAX_DEPTH );
		this.errorSum = this.root.error * this.root.area();

		//Initial Draw
		this.drawNode = this.root;
		this.boxes.push( this.root );
		this.draw();
	}

	get IsRunning()
	{
		return this.isRunning;
	}

	set IsRunning( val )
	{
		this.isRunning = val;
	}

	play()
	{
		this.isRunning = true;
		this.intervalID = setInterval( this.running.bind(this), 1000/ this.framerate );
	}

	step()
	{
		this.isRunning = true;
		if ( this.ITERATIONS <= 0  )
		{
			this.ITERATIONS = 1;
		}
		this.running();
	}

	stop()
	{
		clearInterval(this.intervalID);
		this.isRunning = false;
	}

	running()
	{
		if( this.IsRunning && this.ITERATIONS > 0 )
		{
			this.update();
			this.draw();
		}
	}

	/**
	*	A compareTo function to sort Box's by their error
	**/
	errorCompareTo( a, b )
	{
		if( a.score < b.score )
		{
			return -1;
		}
		if( a.score > b.score)
		{
			return 1;
		}
		return 0;
	}

	/**
	*	Game loop update function
	**/
	update()
	{
		let index =  -1;
		let largestError = 0;

		this.error = this.averageErrorOfQuad( this.drawNode, this.errorSum );

		if( this.previousError == -1 || this.previousError - this.error > ERROR_RATE )
			this.previousError = this.error;

		let leaves = this.root.getAllLeafNodes( [], this.MAX_DEPTH );
		leaves.sort( this.errorCompareTo );
		let last = leaves[0];// leaves[leaves.length-1];
		if( last.error > 0 )
		{
			last.divide();
			this.errorSum -= last.error * last.area();
			let kids = last.getLeafNodes();
			for( let child = 0; child < kids.length; child++ )
			{
				this.errorSum += kids[child].error + kids[child].area();
			}
		}

		this.drawNode = last;
		this.boxes = leaves;
		this.ITERATIONS -= 1;
	}

	averageErrorOfQuad( quad, errorsum )
	{
		return errorsum / quad.area();
	}

	/**
	*
	**/
	getBoxWithLargestError( box )
	{
		if( box.isLeaf() || box.depth >= this.MAX_DEPTH )
		{
			return box;
		}
		else
		{
			let children = box.getLeafNodes();
			children.sort( Box.errorCompareT );
			let largestChild = children[children.length-1];
			return this.getBoxWithLargestError( largestChild );
		}
	}

	/**
	*	Game loop draw function
	**/
	draw()
	{
		this.drawNode.draw( this.ctx);
		for( let i = 0; i < this.drawNode.children.length; i++ )
		{
			this.drawNode.children[i].draw(this.ctx);
		}
		return;
	}

	/**
	*	Gets the average color of a area
	**/
	averageColorOfRegion( x, y, w, h )
	{
		let imgData = this.buffer.getImageData( x, y, w, h );
		let total = imgData.data.length;
		let R = 0, G = 0, B = 0;

		//Manipulate the current section
		for( var i = 0; i < total; i+= 4 )
		{
			//Index of RGBA
			var r = i + 0,
				g = i + 1,
				b = i + 2,
				a = i + 3;

			R = R + imgData.data[r];
			G = G + imgData.data[g];
			B = B + imgData.data[b];
		}
		return {
			r:Math.floor(R/total),
			g:Math.floor(G/total),
			b:Math.floor(B/total)
		};
	}
}

              </script>
              <script type="text/javascript">
                const canvas = document.getElementById("canvas");
                const refpix = document.querySelector('#refpix');
                refpix.addEventListener('load', refpixLoaded );
                canvas.oncontextmenu = (e) => e.preventDefault();
                let halfwidth = canvas.getBoundingClientRect().width;
                let quads = new Quadrants( canvas );
                
                function loadAll()
                {
                    if( quads )
                        quads.stop();
                    const filePicker = document.querySelector('input[type=file]');
                    const reader = new FileReader();
                    const file = filePicker.files[0];
                    reader.addEventListener('load', ( e )=> refpix.src= e.target.result );
                    if (file) {
                        reader.readAsDataURL(file);
                    }
                }
                
                function refpixLoaded()
                {
                    console.log( 'refpixLoaded');
                    console.log( `canvas (${canvas.getBoundingClientRect().width}, ${canvas.getBoundingClientRect().height})`);
                    console.log( `refpix (${refpix.naturalWidth}, ${refpix.naturalHeight})`);
                    quads.initialize( refpix );
                }
                
                function play()
                {
                    console.log( "Program Started");
                    if( quads.ITERATIONS == 0 )
                    {
                        quds.ITERATIONS += 1000;
                    }
                    quads.play();
                };
                function stop()
                {
                    quads.stop();
                    console.log( "Program Halted");
                };
                function step()
                {
                    quads.step();
                    console.log( "Program Stepped");
                };
                function create()
                {
                    quads.stop();
                    playButton.style.display   = 'none';
                    stopButton.style.display   = 'none';
                    pauseButton.style.display  = 'none';
                    createButton.style.display = 'none';
                    var dataUrl = canvas.toDataURL();
                    var img = document.getElementById('refpix');
                    img.src = dataUrl;
                    canvas.style.display = 'none';
                    saveMe.style.display = "block";
                    img.style.display = "block";
                };
              </script>
            </div>
          </div>
        </div>
      </div>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script>feather.replace( {style: 'height:1.1rem;'})</script>
  </body>
</html>